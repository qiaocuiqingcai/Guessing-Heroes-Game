"""
This type stub file was generated by pyright.
"""

import operator
from contextlib import contextmanager
from numba import types
from numba.core.datamodel import models
from numba.core.extending import box, lower_builtin, overload, overload_attribute, overload_method, register_model, type_callable, typeof_impl, unbox
from pandas.core.indexes.base import Index
from pandas.core.indexing import _iLocIndexer
from pandas.core.series import Series

"""
Utility classes/functions to let numba recognize
pandas Index/Series/DataFrame

Mostly vendored from https://github.com/numba/numba/blob/main/numba/tests/pdlike_usecase.py
"""
@contextmanager
def set_numba_data(index: Index): # -> Generator[Index, Any, None]:
    ...

class IndexType(types.Type):
    """
    The type class for Index objects.
    """
    def __init__(self, dtype, layout, pyclass: any) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any, Any]:
        ...
    
    @property
    def as_array(self):
        ...
    
    def copy(self, dtype=..., ndim: int = ..., layout=...): # -> Self:
        ...
    


class SeriesType(types.Type):
    """
    The type class for Series objects.
    """
    def __init__(self, dtype, index, namety) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, IndexType, Any]:
        ...
    
    @property
    def as_array(self):
        ...
    
    def copy(self, dtype=..., ndim: int = ..., layout: str = ...): # -> Self:
        ...
    


@typeof_impl.register(Index)
def typeof_index(val, c): # -> IndexType:
    """
    This will assume that only strings are in object dtype
    index.
    (you should check this before this gets lowered down to numba)
    """
    ...

@typeof_impl.register(Series)
def typeof_series(val, c): # -> SeriesType:
    ...

@type_callable(Series)
def type_series_constructor(context): # -> Callable[..., SeriesType | None]:
    ...

@type_callable(Index)
def type_index_constructor(context): # -> Callable[..., IndexType | None]:
    ...

@register_model(IndexType)
class IndexModel(models.StructModel):
    def __init__(self, dmm, fe_type) -> None:
        ...
    


@register_model(SeriesType)
class SeriesModel(models.StructModel):
    def __init__(self, dmm, fe_type) -> None:
        ...
    


@lower_builtin(Series, types.Array, IndexType)
def pdseries_constructor(context, builder, sig, args):
    ...

@lower_builtin(Series, types.Array, IndexType, types.intp)
@lower_builtin(Series, types.Array, IndexType, types.float64)
@lower_builtin(Series, types.Array, IndexType, types.unicode_type)
def pdseries_constructor_with_name(context, builder, sig, args):
    ...

@lower_builtin(Index, types.Array, types.DictType, types.pyobject)
def index_constructor_2arg(context, builder, sig, args):
    ...

@lower_builtin(Index, types.Array, types.DictType)
def index_constructor_2arg_parent(context, builder, sig, args):
    ...

@lower_builtin(Index, types.Array)
def index_constructor_1arg(context, builder, sig, args):
    ...

def maybe_cast_str(x): # -> None:
    ...

@overload(maybe_cast_str)
def maybe_cast_str_impl(x): # -> Callable[..., str] | Callable[..., Any]:
    """Converts numba UnicodeCharSeq (numpy string scalar) -> unicode type (string).
    Is a no-op for other types."""
    ...

@unbox(IndexType)
def unbox_index(typ, obj, c):
    """
    Convert a Index object to a native structure.

    Note: Object dtype is not allowed here
    """
    ...

@unbox(SeriesType)
def unbox_series(typ, obj, c):
    """
    Convert a Series object to a native structure.
    """
    ...

@box(IndexType)
def box_index(typ, val, c):
    """
    Convert a native index structure to a Index object.

    If our native index is of a numpy string dtype, we'll cast it to
    object.
    """
    ...

@box(SeriesType)
def box_series(typ, val, c):
    """
    Convert a native series structure to a Series object.
    """
    ...

def generate_series_reduction(ser_reduction, ser_method): # -> Callable[..., Callable[..., Any]]:
    ...

def generate_series_binop(binop): # -> Callable[..., Callable[..., Series] | None]:
    ...

series_reductions = ...
series_binops = ...
@overload_method(IndexType, "get_loc")
def index_get_loc(index, item): # -> Callable[..., Any]:
    ...

@overload(operator.getitem)
def series_indexing(series, item): # -> Callable[..., Any] | None:
    ...

@overload(operator.getitem)
def index_indexing(index, idx): # -> Callable[..., Any] | None:
    ...

class IlocType(types.Type):
    def __init__(self, obj_type) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


@typeof_impl.register(_iLocIndexer)
def typeof_iloc(val, c): # -> IlocType:
    ...

@type_callable(_iLocIndexer)
def type_iloc_constructor(context): # -> Callable[..., IlocType | None]:
    ...

@lower_builtin(_iLocIndexer, SeriesType)
def iloc_constructor(context, builder, sig, args):
    ...

@register_model(IlocType)
class ILocModel(models.StructModel):
    def __init__(self, dmm, fe_type) -> None:
        ...
    


@overload_attribute(SeriesType, "iloc")
def series_iloc(series): # -> Callable[..., _iLocIndexer]:
    ...

@overload(operator.getitem)
def iloc_getitem(iloc_indexer, i): # -> Callable[..., Any] | None:
    ...

