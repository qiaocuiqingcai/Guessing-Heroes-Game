"""
This type stub file was generated by pyright.
"""

import numpy as np
from typing import TYPE_CHECKING
from pandas.util._decorators import cache_readonly
from pandas.core.frame import DataFrame
from pandas.core.indexes.api import Index, MultiIndex
from pandas.core.series import Series
from pandas._typing import Level, npt

if TYPE_CHECKING:
    ...
class _Unstacker:
    """
    Helper class to unstack data / pivot with multi-level index

    Parameters
    ----------
    index : MultiIndex
    level : int or str, default last level
        Level to "unstack". Accepts a name for the level.
    fill_value : scalar, optional
        Default value to fill in missing values if subgroups do not have the
        same set of labels. By default, missing values will be replaced with
        the default fill value for that data type, NaN for float, NaT for
        datetimelike, etc. For integer types, by default data will converted to
        float and missing values will be set to NaN.
    constructor : object
        Pandas ``DataFrame`` or subclass used to create unstacked
        response.  If None, DataFrame will be used.

    Examples
    --------
    >>> index = pd.MultiIndex.from_tuples([('one', 'a'), ('one', 'b'),
    ...                                    ('two', 'a'), ('two', 'b')])
    >>> s = pd.Series(np.arange(1, 5, dtype=np.int64), index=index)
    >>> s
    one  a    1
         b    2
    two  a    3
         b    4
    dtype: int64

    >>> s.unstack(level=-1)
         a  b
    one  1  2
    two  3  4

    >>> s.unstack(level=0)
       one  two
    a    1    3
    b    2    4

    Returns
    -------
    unstacked : DataFrame
    """
    def __init__(self, index: MultiIndex, level: Level, constructor, sort: bool = ...) -> None:
        ...
    
    @cache_readonly
    def sorted_labels(self) -> list[np.ndarray]:
        ...
    
    @cache_readonly
    def mask_all(self) -> bool:
        ...
    
    @cache_readonly
    def arange_result(self) -> tuple[npt.NDArray[np.intp], npt.NDArray[np.bool_]]:
        ...
    
    def get_result(self, values, value_columns, fill_value) -> DataFrame:
        ...
    
    def get_new_values(self, values, fill_value=...): # -> tuple[ndarray[tuple[int, int], dtype[Any]], _Array[tuple[int, int], Any]] | tuple[ArrayLike | ndarray[tuple[int, int], Any] | ndarray[_AnyShape, Any] | Any | ndarray[tuple[int, int], dtype[Any]] | _Array[tuple[int, int], float64], _Array[tuple[int, int], Any]]:
        ...
    
    def get_new_columns(self, value_columns: Index | None): # -> MultiIndex:
        ...
    
    @cache_readonly
    def new_index(self) -> MultiIndex:
        ...
    


def unstack(obj: Series | DataFrame, level, fill_value=..., sort: bool = ...): # -> Series | DataFrame:
    ...

def stack(frame: DataFrame, level=..., dropna: bool = ..., sort: bool = ...): # -> DataFrame | Series:
    """
    Convert DataFrame to Series with multi-level Index. Columns become the
    second level of the resulting hierarchical index

    Returns
    -------
    stacked : Series or DataFrame
    """
    ...

def stack_multiple(frame: DataFrame, level, dropna: bool = ..., sort: bool = ...): # -> DataFrame | Series:
    ...

def stack_v3(frame: DataFrame, level: list[int]) -> Series | DataFrame:
    ...

