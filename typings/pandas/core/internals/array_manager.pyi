"""
This type stub file was generated by pyright.
"""

import numpy as np
from typing import Callable, Literal, TYPE_CHECKING
from pandas.core.arrays import ExtensionArray
from pandas.core.indexes.api import Index
from pandas.core.internals.base import DataManager, SingleDataManager
from collections.abc import Hashable
from pandas._typing import ArrayLike, AxisInt, DtypeObj, QuantileInterpolation, Self, npt

"""
Experimental manager based on storing a collection of 1D arrays
"""
if TYPE_CHECKING:
    ...
class BaseArrayManager(DataManager):
    """
    Core internal data structure to implement DataFrame and Series.

    Alternative to the BlockManager, storing a list of 1D arrays instead of
    Blocks.

    This is *not* a public API class

    Parameters
    ----------
    arrays : Sequence of arrays
    axes : Sequence of Index
    verify_integrity : bool, default True

    """
    __slots__ = ...
    arrays: list[np.ndarray | ExtensionArray]
    _axes: list[Index]
    def __init__(self, arrays: list[np.ndarray | ExtensionArray], axes: list[Index], verify_integrity: bool = ...) -> None:
        ...
    
    def make_empty(self, axes=...) -> Self:
        """Return an empty ArrayManager with the items axis of len 0 (no columns)"""
        ...
    
    @property
    def items(self) -> Index:
        ...
    
    @property
    def axes(self) -> list[Index]:
        """Axes is BlockManager-compatible order (columns, rows)"""
        ...
    
    @property
    def shape_proper(self) -> tuple[int, ...]:
        ...
    
    def set_axis(self, axis: AxisInt, new_labels: Index) -> None:
        ...
    
    def get_dtypes(self) -> npt.NDArray[np.object_]:
        ...
    
    def add_references(self, mgr: BaseArrayManager) -> None:
        """
        Only implemented on the BlockManager level
        """
        ...
    
    def __getstate__(self): # -> tuple[list[ndarray[_AnyShape, dtype[Any]] | ExtensionArray], list[Index]]:
        ...
    
    def __setstate__(self, state) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def apply(self, f, align_keys: list[str] | None = ..., **kwargs) -> Self:
        """
        Iterate over the arrays, collect and create a new ArrayManager.

        Parameters
        ----------
        f : str or callable
            Name of the Array method to apply.
        align_keys: List[str] or None, default None
        **kwargs
            Keywords to pass to `f`

        Returns
        -------
        ArrayManager
        """
        ...
    
    def apply_with_block(self, f, align_keys=..., **kwargs) -> Self:
        ...
    
    def setitem(self, indexer, value, warn: bool = ...) -> Self:
        ...
    
    def diff(self, n: int) -> Self:
        ...
    
    def astype(self, dtype, copy: bool | None = ..., errors: str = ...) -> Self:
        ...
    
    def convert(self, copy: bool | None) -> Self:
        ...
    
    def get_values_for_csv(self, *, float_format, date_format, decimal, na_rep: str = ..., quoting=...) -> Self:
        ...
    
    @property
    def any_extension_types(self) -> bool:
        """Whether any of the blocks in this manager are extension blocks"""
        ...
    
    @property
    def is_view(self) -> bool:
        """return a boolean if we are a single block and are a view"""
        ...
    
    @property
    def is_single_block(self) -> bool:
        ...
    
    def get_bool_data(self, copy: bool = ...) -> Self:
        """
        Select columns that are bool-dtype and object-dtype columns that are all-bool.

        Parameters
        ----------
        copy : bool, default False
            Whether to copy the blocks
        """
        ...
    
    def get_numeric_data(self, copy: bool = ...) -> Self:
        """
        Select columns that have a numeric dtype.

        Parameters
        ----------
        copy : bool, default False
            Whether to copy the blocks
        """
        ...
    
    def copy(self, deep: bool | Literal["all"] | None = ...) -> Self:
        """
        Make deep or shallow copy of ArrayManager

        Parameters
        ----------
        deep : bool or string, default True
            If False, return shallow copy (do not copy data)
            If 'all', copy data and a deep copy of the index

        Returns
        -------
        BlockManager
        """
        ...
    
    def reindex_indexer(self, new_axis, indexer, axis: AxisInt, fill_value=..., allow_dups: bool = ..., copy: bool | None = ..., only_slice: bool = ..., use_na_proxy: bool = ...) -> Self:
        ...
    
    def take(self, indexer: npt.NDArray[np.intp], axis: AxisInt = ..., verify: bool = ...) -> Self:
        """
        Take items along any axis.
        """
        ...
    


class ArrayManager(BaseArrayManager):
    @property
    def ndim(self) -> Literal[2]:
        ...
    
    def __init__(self, arrays: list[np.ndarray | ExtensionArray], axes: list[Index], verify_integrity: bool = ...) -> None:
        ...
    
    def fast_xs(self, loc: int) -> SingleArrayManager:
        """
        Return the array corresponding to `frame.iloc[loc]`.

        Parameters
        ----------
        loc : int

        Returns
        -------
        np.ndarray or ExtensionArray
        """
        ...
    
    def get_slice(self, slobj: slice, axis: AxisInt = ...) -> ArrayManager:
        ...
    
    def iget(self, i: int) -> SingleArrayManager:
        """
        Return the data as a SingleArrayManager.
        """
        ...
    
    def iget_values(self, i: int) -> ArrayLike:
        """
        Return the data for column i as the values (ndarray or ExtensionArray).
        """
        ...
    
    @property
    def column_arrays(self) -> list[ArrayLike]:
        """
        Used in the JSON C code to access column arrays.
        """
        ...
    
    def iset(self, loc: int | slice | np.ndarray, value: ArrayLike, inplace: bool = ..., refs=...) -> None:
        """
        Set new column(s).

        This changes the ArrayManager in-place, but replaces (an) existing
        column(s), not changing column values in-place).

        Parameters
        ----------
        loc : integer, slice or boolean mask
            Positional location (already bounds checked)
        value : np.ndarray or ExtensionArray
        inplace : bool, default False
            Whether overwrite existing array as opposed to replacing it.
        """
        ...
    
    def column_setitem(self, loc: int, idx: int | slice | np.ndarray, value, inplace_only: bool = ...) -> None:
        """
        Set values ("setitem") into a single column (not setting the full column).

        This is a method on the ArrayManager level, to avoid creating an
        intermediate Series at the DataFrame level (`s = df[loc]; s[idx] = value`)
        """
        ...
    
    def insert(self, loc: int, item: Hashable, value: ArrayLike, refs=...) -> None:
        """
        Insert item at selected position.

        Parameters
        ----------
        loc : int
        item : hashable
        value : np.ndarray or ExtensionArray
        """
        ...
    
    def idelete(self, indexer) -> ArrayManager:
        """
        Delete selected locations in-place (new block and array, same BlockManager)
        """
        ...
    
    def grouped_reduce(self, func: Callable) -> Self:
        """
        Apply grouped reduction function columnwise, returning a new ArrayManager.

        Parameters
        ----------
        func : grouped reduction function

        Returns
        -------
        ArrayManager
        """
        ...
    
    def reduce(self, func: Callable) -> Self:
        """
        Apply reduction function column-wise, returning a single-row ArrayManager.

        Parameters
        ----------
        func : reduction function

        Returns
        -------
        ArrayManager
        """
        ...
    
    def operate_blockwise(self, other: ArrayManager, array_op) -> ArrayManager:
        """
        Apply array_op blockwise with another (aligned) BlockManager.
        """
        ...
    
    def quantile(self, *, qs: Index, transposed: bool = ..., interpolation: QuantileInterpolation = ...) -> ArrayManager:
        ...
    
    def unstack(self, unstacker, fill_value) -> ArrayManager:
        """
        Return a BlockManager with all blocks unstacked.

        Parameters
        ----------
        unstacker : reshape._Unstacker
        fill_value : Any
            fill_value for newly introduced missing values.

        Returns
        -------
        unstacked : BlockManager
        """
        ...
    
    def as_array(self, dtype=..., copy: bool = ..., na_value: object = ...) -> np.ndarray:
        """
        Convert the blockmanager data into an numpy array.

        Parameters
        ----------
        dtype : object, default None
            Data type of the return array.
        copy : bool, default False
            If True then guarantee that a copy is returned. A value of
            False does not guarantee that the underlying data is not
            copied.
        na_value : object, default lib.no_default
            Value to be used as the missing value sentinel.

        Returns
        -------
        arr : ndarray
        """
        ...
    
    @classmethod
    def concat_horizontal(cls, mgrs: list[Self], axes: list[Index]) -> Self:
        """
        Concatenate uniformly-indexed ArrayManagers horizontally.
        """
        ...
    
    @classmethod
    def concat_vertical(cls, mgrs: list[Self], axes: list[Index]) -> Self:
        """
        Concatenate uniformly-indexed ArrayManagers vertically.
        """
        ...
    


class SingleArrayManager(BaseArrayManager, SingleDataManager):
    __slots__ = ...
    arrays: list[np.ndarray | ExtensionArray]
    _axes: list[Index]
    @property
    def ndim(self) -> Literal[1]:
        ...
    
    def __init__(self, arrays: list[np.ndarray | ExtensionArray], axes: list[Index], verify_integrity: bool = ...) -> None:
        ...
    
    def make_empty(self, axes=...) -> Self:
        """Return an empty ArrayManager with index/array of length 0"""
        ...
    
    @classmethod
    def from_array(cls, array, index) -> SingleArrayManager:
        ...
    
    @property
    def axes(self) -> list[Index]:
        ...
    
    @property
    def index(self) -> Index:
        ...
    
    @property
    def dtype(self): # -> ExtensionDtype | dtype[Any]:
        ...
    
    def external_values(self): # -> ArrayLike:
        """The array that Series.values returns"""
        ...
    
    def internal_values(self): # -> ArrayLike:
        """The array that Series._values returns"""
        ...
    
    def array_values(self): # -> NumpyExtensionArray | ExtensionArray:
        """The array that Series.array returns"""
        ...
    
    @property
    def is_single_block(self) -> bool:
        ...
    
    def fast_xs(self, loc: int) -> SingleArrayManager:
        ...
    
    def get_slice(self, slobj: slice, axis: AxisInt = ...) -> SingleArrayManager:
        ...
    
    def get_rows_with_mask(self, indexer: npt.NDArray[np.bool_]) -> SingleArrayManager:
        ...
    
    def apply(self, func, **kwargs) -> Self:
        ...
    
    def setitem(self, indexer, value, warn: bool = ...) -> SingleArrayManager:
        """
        Set values with indexer.

        For SingleArrayManager, this backs s[indexer] = value

        See `setitem_inplace` for a version that works inplace and doesn't
        return a new Manager.
        """
        ...
    
    def idelete(self, indexer) -> SingleArrayManager:
        """
        Delete selected locations in-place (new array, same ArrayManager)
        """
        ...
    
    def set_values(self, values: ArrayLike) -> None:
        """
        Set (replace) the values of the SingleArrayManager in place.

        Use at your own risk! This does not check if the passed values are
        valid for the current SingleArrayManager (length, dtype, etc).
        """
        ...
    
    def to_2d_mgr(self, columns: Index) -> ArrayManager:
        """
        Manager analogue of Series.to_frame
        """
        ...
    


class NullArrayProxy:
    """
    Proxy object for an all-NA array.

    Only stores the length of the array, and not the dtype. The dtype
    will only be known when actually concatenating (after determining the
    common dtype, for which this proxy is ignored).
    Using this object avoids that the internals/concat.py needs to determine
    the proper dtype and array type.
    """
    ndim = ...
    def __init__(self, n: int) -> None:
        ...
    
    @property
    def shape(self) -> tuple[int]:
        ...
    
    def to_array(self, dtype: DtypeObj) -> ArrayLike:
        """
        Helper function to create the actual all-NA array from the NullArrayProxy
        object.

        Parameters
        ----------
        arr : NullArrayProxy
        dtype : the dtype for the resulting array

        Returns
        -------
        np.ndarray or ExtensionArray
        """
        ...
    


def concat_arrays(to_concat: list) -> ArrayLike:
    """
    Alternative for concat_compat but specialized for use in the ArrayManager.

    Differences: only deals with 1D arrays (no axis keyword), assumes
    ensure_wrapped_if_datetimelike and does not skip empty arrays to determine
    the dtype.
    In addition ensures that all NullArrayProxies get replaced with actual
    arrays.

    Parameters
    ----------
    to_concat : list of arrays

    Returns
    -------
    np.ndarray or ExtensionArray
    """
    ...

