"""
This type stub file was generated by pyright.
"""

import numpy as np
from typing import TYPE_CHECKING
from pandas._libs.tslibs import Tick
from pandas.core.arrays import datetimelike as dtl
from pandas.core.ops.common import unpack_zerodim_and_defer
from collections.abc import Iterator
from pandas._typing import AxisInt, DateTimeErrorChoices, NpDtype, Self, npt
from pandas import DataFrame

if TYPE_CHECKING:
    ...
class TimedeltaArray(dtl.TimelikeOps):
    """
    Pandas ExtensionArray for timedelta data.

    .. warning::

       TimedeltaArray is currently experimental, and its API may change
       without warning. In particular, :attr:`TimedeltaArray.dtype` is
       expected to change to be an instance of an ``ExtensionDtype``
       subclass.

    Parameters
    ----------
    values : array-like
        The timedelta data.

    dtype : numpy.dtype
        Currently, only ``numpy.dtype("timedelta64[ns]")`` is accepted.
    freq : Offset, optional
    copy : bool, default False
        Whether to copy the underlying array of data.

    Attributes
    ----------
    None

    Methods
    -------
    None

    Examples
    --------
    >>> pd.arrays.TimedeltaArray._from_sequence(pd.TimedeltaIndex(['1h', '2h']))
    <TimedeltaArray>
    ['0 days 01:00:00', '0 days 02:00:00']
    Length: 2, dtype: timedelta64[ns]
    """
    _typ = ...
    _internal_fill_value = ...
    _recognized_scalars = ...
    _is_recognized_dtype = ...
    _infer_matches = ...
    __array_priority__ = ...
    _other_ops: list[str] = ...
    _bool_ops: list[str] = ...
    _object_ops: list[str] = ...
    _field_ops: list[str] = ...
    _datetimelike_ops: list[str] = ...
    _datetimelike_methods: list[str] = ...
    @property
    def dtype(self) -> np.dtype[np.timedelta64]:
        """
        The dtype for the TimedeltaArray.

        .. warning::

           A future version of pandas will change dtype to be an instance
           of a :class:`pandas.api.extensions.ExtensionDtype` subclass,
           not a ``numpy.dtype``.

        Returns
        -------
        numpy.dtype
        """
        ...
    
    _freq = ...
    _default_dtype = ...
    def astype(self, dtype, copy: bool = ...): # -> Self | NDArray[object_] | ndarray[tuple[int, ...], dtype[Any]] | ExtensionArray | NDArray[int64] | NDArray[Any]:
        ...
    
    def __iter__(self) -> Iterator:
        ...
    
    def sum(self, *, axis: AxisInt | None = ..., dtype: NpDtype | None = ..., out=..., keepdims: bool = ..., initial=..., skipna: bool = ..., min_count: int = ...):
        ...
    
    def std(self, *, axis: AxisInt | None = ..., dtype: NpDtype | None = ..., out=..., ddof: int = ..., keepdims: bool = ..., skipna: bool = ...): # -> Timedelta | NaTType:
        ...
    
    @unpack_zerodim_and_defer("__mul__")
    def __mul__(self, other) -> Self:
        ...
    
    __rmul__ = ...
    @unpack_zerodim_and_defer("__truediv__")
    def __truediv__(self, other): # -> _Array[tuple[int, ...], float64] | Self | ndarray[_AnyShape, dtype[Any]] | NDArray[Any] | _NotImplementedType:
        ...
    
    @unpack_zerodim_and_defer("__rtruediv__")
    def __rtruediv__(self, other): # -> _Array[tuple[int, ...], float64] | Self | ndarray[_AnyShape, dtype[Any]] | NDArray[Any] | _NotImplementedType:
        ...
    
    @unpack_zerodim_and_defer("__floordiv__")
    def __floordiv__(self, other): # -> _Array[tuple[int, ...], float64] | Self | ndarray[_AnyShape, dtype[Any]] | NDArray[Any] | _NotImplementedType:
        ...
    
    @unpack_zerodim_and_defer("__rfloordiv__")
    def __rfloordiv__(self, other): # -> _Array[tuple[int, ...], float64] | Self | ndarray[_AnyShape, dtype[Any]] | NDArray[Any] | _NotImplementedType:
        ...
    
    @unpack_zerodim_and_defer("__mod__")
    def __mod__(self, other): # -> _NotImplementedType | TimedeltaArray | DatetimeArray | PeriodArray | ndarray[tuple[int, ...], dtype[Any]] | ndarray[Any, Any] | ndarray[_AnyShape, dtype[object_]] | Any:
        ...
    
    @unpack_zerodim_and_defer("__rmod__")
    def __rmod__(self, other): # -> _NotImplementedType | TimedeltaArray | DatetimeArray | PeriodArray | ndarray[tuple[int, ...], dtype[Any]] | ndarray[Any, Any] | ndarray[_AnyShape, dtype[object_]] | Any:
        ...
    
    @unpack_zerodim_and_defer("__divmod__")
    def __divmod__(self, other): # -> tuple[_Array[tuple[int, ...], float64] | Any | Self | ndarray[_AnyShape, dtype[Any]] | NDArray[Any] | _NotImplementedType, Any | _NotImplementedType | TimedeltaArray | DatetimeArray | PeriodArray | ndarray[tuple[int, ...], dtype[Any]] | ndarray[Any, Any] | ndarray[_AnyShape, dtype[object_]]]:
        ...
    
    @unpack_zerodim_and_defer("__rdivmod__")
    def __rdivmod__(self, other): # -> tuple[_Array[tuple[int, ...], float64] | Any | Self | ndarray[_AnyShape, dtype[Any]] | NDArray[Any] | _NotImplementedType, Any | _NotImplementedType | TimedeltaArray | DatetimeArray | PeriodArray | ndarray[tuple[int, ...], dtype[Any]] | ndarray[Any, Any] | ndarray[_AnyShape, dtype[object_]]]:
        ...
    
    def __neg__(self) -> TimedeltaArray:
        ...
    
    def __pos__(self) -> TimedeltaArray:
        ...
    
    def __abs__(self) -> TimedeltaArray:
        ...
    
    def total_seconds(self) -> npt.NDArray[np.float64]:
        """
        Return total duration of each element expressed in seconds.

        This method is available directly on TimedeltaArray, TimedeltaIndex
        and on Series containing timedelta values under the ``.dt`` namespace.

        Returns
        -------
        ndarray, Index or Series
            When the calling object is a TimedeltaArray, the return type
            is ndarray.  When the calling object is a TimedeltaIndex,
            the return type is an Index with a float64 dtype. When the calling object
            is a Series, the return type is Series of type `float64` whose
            index is the same as the original.

        See Also
        --------
        datetime.timedelta.total_seconds : Standard library version
            of this method.
        TimedeltaIndex.components : Return a DataFrame with components of
            each Timedelta.

        Examples
        --------
        **Series**

        >>> s = pd.Series(pd.to_timedelta(np.arange(5), unit='d'))
        >>> s
        0   0 days
        1   1 days
        2   2 days
        3   3 days
        4   4 days
        dtype: timedelta64[ns]

        >>> s.dt.total_seconds()
        0         0.0
        1     86400.0
        2    172800.0
        3    259200.0
        4    345600.0
        dtype: float64

        **TimedeltaIndex**

        >>> idx = pd.to_timedelta(np.arange(5), unit='d')
        >>> idx
        TimedeltaIndex(['0 days', '1 days', '2 days', '3 days', '4 days'],
                       dtype='timedelta64[ns]', freq=None)

        >>> idx.total_seconds()
        Index([0.0, 86400.0, 172800.0, 259200.0, 345600.0], dtype='float64')
        """
        ...
    
    def to_pytimedelta(self) -> npt.NDArray[np.object_]:
        """
        Return an ndarray of datetime.timedelta objects.

        Returns
        -------
        numpy.ndarray

        Examples
        --------
        >>> tdelta_idx = pd.to_timedelta([1, 2, 3], unit='D')
        >>> tdelta_idx
        TimedeltaIndex(['1 days', '2 days', '3 days'],
                        dtype='timedelta64[ns]', freq=None)
        >>> tdelta_idx.to_pytimedelta()
        array([datetime.timedelta(days=1), datetime.timedelta(days=2),
               datetime.timedelta(days=3)], dtype=object)
        """
        ...
    
    days_docstring = ...
    days = ...
    seconds_docstring = ...
    seconds = ...
    microseconds_docstring = ...
    microseconds = ...
    nanoseconds_docstring = ...
    nanoseconds = ...
    @property
    def components(self) -> DataFrame:
        """
        Return a DataFrame of the individual resolution components of the Timedeltas.

        The components (days, hours, minutes seconds, milliseconds, microseconds,
        nanoseconds) are returned as columns in a DataFrame.

        Returns
        -------
        DataFrame

        Examples
        --------
        >>> tdelta_idx = pd.to_timedelta(['1 day 3 min 2 us 42 ns'])
        >>> tdelta_idx
        TimedeltaIndex(['1 days 00:03:00.000002042'],
                       dtype='timedelta64[ns]', freq=None)
        >>> tdelta_idx.components
           days  hours  minutes  seconds  milliseconds  microseconds  nanoseconds
        0     1      0        3        0             0             2           42
        """
        ...
    


def sequence_to_td64ns(data, copy: bool = ..., unit=..., errors: DateTimeErrorChoices = ...) -> tuple[np.ndarray, Tick | None]:
    """
    Parameters
    ----------
    data : list-like
    copy : bool, default False
    unit : str, optional
        The timedelta unit to treat integers as multiples of. For numeric
        data this defaults to ``'ns'``.
        Must be un-specified if the data contains a str and ``errors=="raise"``.
    errors : {"raise", "coerce", "ignore"}, default "raise"
        How to handle elements that cannot be converted to timedelta64[ns].
        See ``pandas.to_timedelta`` for details.

    Returns
    -------
    converted : numpy.ndarray
        The sequence converted to a numpy array with dtype ``timedelta64[ns]``.
    inferred_freq : Tick or None
        The inferred frequency of the sequence.

    Raises
    ------
    ValueError : Data cannot be converted to timedelta64[ns].

    Notes
    -----
    Unlike `pandas.to_timedelta`, if setting ``errors=ignore`` will not cause
    errors to be ignored; they are caught and subsequently ignored at a
    higher level.
    """
    ...

