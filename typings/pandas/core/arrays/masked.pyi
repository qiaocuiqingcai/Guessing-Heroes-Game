"""
This type stub file was generated by pyright.
"""

import numpy as np
from typing import Any, Literal, TYPE_CHECKING, overload
from pandas._typing import ArrayLike, AstypeArg, AxisInt, InterpolateOptions, NpDtype, NumpySorter, NumpyValueArrayLike, PositionalIndexer, Scalar, ScalarIndexer, Self, SequenceIndexer, Shape, npt
from pandas.util._decorators import doc
from pandas.core.dtypes.base import ExtensionDtype
from pandas.core.dtypes.dtypes import BaseMaskedDtype
from pandas.core.arraylike import OpsMixin
from pandas.core.arrays.base import ExtensionArray
from collections.abc import Iterator, Sequence
from pandas import Series
from pandas.core.arrays import BooleanArray, FloatingArray

if TYPE_CHECKING:
    ...
class BaseMaskedArray(OpsMixin, ExtensionArray):
    """
    Base class for masked arrays (which use _data and _mask to store the data).

    numpy based
    """
    _internal_fill_value: Scalar
    _data: np.ndarray
    _mask: npt.NDArray[np.bool_]
    _truthy_value = Scalar
    _falsey_value = Scalar
    def __init__(self, values: np.ndarray, mask: npt.NDArray[np.bool_], copy: bool = ...) -> None:
        ...
    
    @property
    def dtype(self) -> BaseMaskedDtype:
        ...
    
    @overload
    def __getitem__(self, item: ScalarIndexer) -> Any:
        ...
    
    @overload
    def __getitem__(self, item: SequenceIndexer) -> Self:
        ...
    
    def __getitem__(self, item: PositionalIndexer) -> Self | Any:
        ...
    
    @doc(ExtensionArray.fillna)
    def fillna(self, value=..., method=..., limit: int | None = ..., copy: bool = ...) -> Self:
        ...
    
    def __setitem__(self, key, value) -> None:
        ...
    
    def __contains__(self, key) -> bool:
        ...
    
    def __iter__(self) -> Iterator:
        ...
    
    def __len__(self) -> int:
        ...
    
    @property
    def shape(self) -> Shape:
        ...
    
    @property
    def ndim(self) -> int:
        ...
    
    def swapaxes(self, axis1, axis2) -> Self:
        ...
    
    def delete(self, loc, axis: AxisInt = ...) -> Self:
        ...
    
    def reshape(self, *args, **kwargs) -> Self:
        ...
    
    def ravel(self, *args, **kwargs) -> Self:
        ...
    
    @property
    def T(self) -> Self:
        ...
    
    def round(self, decimals: int = ..., *args, **kwargs): # -> Self | tuple[tuple[Any, tuple[Any, Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]]] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]], tuple[tuple[Any, tuple[Any, Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]]] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]], Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]]] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]]:
        """
        Round each value in the array a to the given number of decimals.

        Parameters
        ----------
        decimals : int, default 0
            Number of decimal places to round to. If decimals is negative,
            it specifies the number of positions to the left of the decimal point.
        *args, **kwargs
            Additional arguments and keywords have no effect but might be
            accepted for compatibility with NumPy.

        Returns
        -------
        NumericArray
            Rounded values of the NumericArray.

        See Also
        --------
        numpy.around : Round values of an np.array.
        DataFrame.round : Round values of a DataFrame.
        Series.round : Round values of a Series.
        """
        ...
    
    def __invert__(self) -> Self:
        ...
    
    def __neg__(self) -> Self:
        ...
    
    def __pos__(self) -> Self:
        ...
    
    def __abs__(self) -> Self:
        ...
    
    def to_numpy(self, dtype: npt.DTypeLike | None = ..., copy: bool = ..., na_value: object = ...) -> np.ndarray:
        """
        Convert to a NumPy Array.

        By default converts to an object-dtype NumPy array. Specify the `dtype` and
        `na_value` keywords to customize the conversion.

        Parameters
        ----------
        dtype : dtype, default object
            The numpy dtype to convert to.
        copy : bool, default False
            Whether to ensure that the returned value is a not a view on
            the array. Note that ``copy=False`` does not *ensure* that
            ``to_numpy()`` is no-copy. Rather, ``copy=True`` ensure that
            a copy is made, even if not strictly necessary. This is typically
            only possible when no missing values are present and `dtype`
            is the equivalent numpy dtype.
        na_value : scalar, optional
             Scalar missing value indicator to use in numpy array. Defaults
             to the native missing value indicator of this array (pd.NA).

        Returns
        -------
        numpy.ndarray

        Examples
        --------
        An object-dtype is the default result

        >>> a = pd.array([True, False, pd.NA], dtype="boolean")
        >>> a.to_numpy()
        array([True, False, <NA>], dtype=object)

        When no missing values are present, an equivalent dtype can be used.

        >>> pd.array([True, False], dtype="boolean").to_numpy(dtype="bool")
        array([ True, False])
        >>> pd.array([1, 2], dtype="Int64").to_numpy("int64")
        array([1, 2])

        However, requesting such dtype will raise a ValueError if
        missing values are present and the default missing value :attr:`NA`
        is used.

        >>> a = pd.array([True, False, pd.NA], dtype="boolean")
        >>> a
        <BooleanArray>
        [True, False, <NA>]
        Length: 3, dtype: boolean

        >>> a.to_numpy(dtype="bool")
        Traceback (most recent call last):
        ...
        ValueError: cannot convert to bool numpy array in presence of missing values

        Specify a valid `na_value` instead

        >>> a.to_numpy(dtype="bool", na_value=False)
        array([ True, False, False])
        """
        ...
    
    @doc(ExtensionArray.tolist)
    def tolist(self): # -> list[Any] | Any:
        ...
    
    @overload
    def astype(self, dtype: npt.DTypeLike, copy: bool = ...) -> np.ndarray:
        ...
    
    @overload
    def astype(self, dtype: ExtensionDtype, copy: bool = ...) -> ExtensionArray:
        ...
    
    @overload
    def astype(self, dtype: AstypeArg, copy: bool = ...) -> ArrayLike:
        ...
    
    def astype(self, dtype: AstypeArg, copy: bool = ...) -> ArrayLike:
        ...
    
    __array_priority__ = ...
    def __array__(self, dtype: NpDtype | None = ..., copy: bool | None = ...) -> np.ndarray:
        """
        the array interface, return my values
        We return an object array here to preserve our scalar values
        """
        ...
    
    _HANDLED_TYPES: tuple[type, ...]
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): # -> _NotImplementedType | tuple[Any, ...] | Any | tuple[BooleanArray | IntegerArray | FloatingArray | ndarray[_AnyShape, dtype[Any]], ...] | NAType | BooleanArray | IntegerArray | FloatingArray | ndarray[_AnyShape, dtype[Any]]:
        ...
    
    def __arrow_array__(self, type=...):
        """
        Convert myself into a pyarrow Array.
        """
        ...
    
    _logical_method = ...
    def isna(self) -> np.ndarray:
        ...
    
    @property
    def nbytes(self) -> int:
        ...
    
    def take(self, indexer, *, allow_fill: bool = ..., fill_value: Scalar | None = ..., axis: AxisInt = ...) -> Self:
        ...
    
    def isin(self, values: ArrayLike) -> BooleanArray:
        ...
    
    def copy(self) -> Self:
        ...
    
    @doc(ExtensionArray.duplicated)
    def duplicated(self, keep: Literal["first", "last", False] = ...) -> npt.NDArray[np.bool_]:
        ...
    
    def unique(self) -> Self:
        """
        Compute the BaseMaskedArray of unique values.

        Returns
        -------
        uniques : BaseMaskedArray
        """
        ...
    
    @doc(ExtensionArray.searchsorted)
    def searchsorted(self, value: NumpyValueArrayLike | ExtensionArray, side: Literal["left", "right"] = ..., sorter: NumpySorter | None = ...) -> npt.NDArray[np.intp] | np.intp:
        ...
    
    @doc(ExtensionArray.factorize)
    def factorize(self, use_na_sentinel: bool = ...) -> tuple[np.ndarray, ExtensionArray]:
        ...
    
    def value_counts(self, dropna: bool = ...) -> Series:
        """
        Returns a Series containing counts of each unique value.

        Parameters
        ----------
        dropna : bool, default True
            Don't include counts of missing values.

        Returns
        -------
        counts : Series

        See Also
        --------
        Series.value_counts
        """
        ...
    
    @doc(ExtensionArray.equals)
    def equals(self, other) -> bool:
        ...
    
    def sum(self, *, skipna: bool = ..., min_count: int = ..., axis: AxisInt | None = ..., **kwargs): # -> tuple[tuple[Any, Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]], Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]] | tuple[Any, Any]:
        ...
    
    def prod(self, *, skipna: bool = ..., min_count: int = ..., axis: AxisInt | None = ..., **kwargs): # -> tuple[tuple[Any, Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]], Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]] | tuple[Any, Any]:
        ...
    
    def mean(self, *, skipna: bool = ..., axis: AxisInt | None = ..., **kwargs): # -> tuple[Any, Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]]:
        ...
    
    def var(self, *, skipna: bool = ..., axis: AxisInt | None = ..., ddof: int = ..., **kwargs): # -> tuple[Any, Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]]:
        ...
    
    def std(self, *, skipna: bool = ..., axis: AxisInt | None = ..., ddof: int = ..., **kwargs): # -> tuple[Any, Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]]:
        ...
    
    def min(self, *, skipna: bool = ..., axis: AxisInt | None = ..., **kwargs): # -> tuple[Any, Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]]:
        ...
    
    def max(self, *, skipna: bool = ..., axis: AxisInt | None = ..., **kwargs): # -> tuple[Any, Any] | FloatingArray | BooleanArray | TimedeltaArray | <subclass of ndarray[_AnyShape, dtype[Any]] and TimedeltaArray> | IntegerArray | ndarray[_AnyShape, dtype[Any]]:
        ...
    
    def map(self, mapper, na_action=...): # -> ndarray[_AnyShape, dtype[Any]] | ExtensionArray | Index:
        ...
    
    def any(self, *, skipna: bool = ..., axis: AxisInt | None = ..., **kwargs): # -> numpy.bool[builtins.bool] | NAType:
        """
        Return whether any element is truthy.

        Returns False unless there is at least one element that is truthy.
        By default, NAs are skipped. If ``skipna=False`` is specified and
        missing values are present, similar :ref:`Kleene logic <boolean.kleene>`
        is used as for logical operations.

        .. versionchanged:: 1.4.0

        Parameters
        ----------
        skipna : bool, default True
            Exclude NA values. If the entire array is NA and `skipna` is
            True, then the result will be False, as for an empty array.
            If `skipna` is False, the result will still be True if there is
            at least one element that is truthy, otherwise NA will be returned
            if there are NA's present.
        axis : int, optional, default 0
        **kwargs : any, default None
            Additional keywords have no effect but might be accepted for
            compatibility with NumPy.

        Returns
        -------
        bool or :attr:`pandas.NA`

        See Also
        --------
        numpy.any : Numpy version of this method.
        BaseMaskedArray.all : Return whether all elements are truthy.

        Examples
        --------
        The result indicates whether any element is truthy (and by default
        skips NAs):

        >>> pd.array([True, False, True]).any()
        True
        >>> pd.array([True, False, pd.NA]).any()
        True
        >>> pd.array([False, False, pd.NA]).any()
        False
        >>> pd.array([], dtype="boolean").any()
        False
        >>> pd.array([pd.NA], dtype="boolean").any()
        False
        >>> pd.array([pd.NA], dtype="Float64").any()
        False

        With ``skipna=False``, the result can be NA if this is logically
        required (whether ``pd.NA`` is True or False influences the result):

        >>> pd.array([True, False, pd.NA]).any(skipna=False)
        True
        >>> pd.array([1, 0, pd.NA]).any(skipna=False)
        True
        >>> pd.array([False, False, pd.NA]).any(skipna=False)
        <NA>
        >>> pd.array([0, 0, pd.NA]).any(skipna=False)
        <NA>
        """
        ...
    
    def all(self, *, skipna: bool = ..., axis: AxisInt | None = ..., **kwargs): # -> numpy.bool[builtins.bool] | NDArray[numpy.bool[builtins.bool]] | NAType:
        """
        Return whether all elements are truthy.

        Returns True unless there is at least one element that is falsey.
        By default, NAs are skipped. If ``skipna=False`` is specified and
        missing values are present, similar :ref:`Kleene logic <boolean.kleene>`
        is used as for logical operations.

        .. versionchanged:: 1.4.0

        Parameters
        ----------
        skipna : bool, default True
            Exclude NA values. If the entire array is NA and `skipna` is
            True, then the result will be True, as for an empty array.
            If `skipna` is False, the result will still be False if there is
            at least one element that is falsey, otherwise NA will be returned
            if there are NA's present.
        axis : int, optional, default 0
        **kwargs : any, default None
            Additional keywords have no effect but might be accepted for
            compatibility with NumPy.

        Returns
        -------
        bool or :attr:`pandas.NA`

        See Also
        --------
        numpy.all : Numpy version of this method.
        BooleanArray.any : Return whether any element is truthy.

        Examples
        --------
        The result indicates whether all elements are truthy (and by default
        skips NAs):

        >>> pd.array([True, True, pd.NA]).all()
        True
        >>> pd.array([1, 1, pd.NA]).all()
        True
        >>> pd.array([True, False, pd.NA]).all()
        False
        >>> pd.array([], dtype="boolean").all()
        True
        >>> pd.array([pd.NA], dtype="boolean").all()
        True
        >>> pd.array([pd.NA], dtype="Float64").all()
        True

        With ``skipna=False``, the result can be NA if this is logically
        required (whether ``pd.NA`` is True or False influences the result):

        >>> pd.array([True, True, pd.NA]).all(skipna=False)
        <NA>
        >>> pd.array([1, 1, pd.NA]).all(skipna=False)
        <NA>
        >>> pd.array([True, False, pd.NA]).all(skipna=False)
        False
        >>> pd.array([1, 0, pd.NA]).all(skipna=False)
        False
        """
        ...
    
    def interpolate(self, *, method: InterpolateOptions, axis: int, index, limit, limit_direction, limit_area, copy: bool, **kwargs) -> FloatingArray:
        """
        See NDFrame.interpolate.__doc__.
        """
        ...
    


def transpose_homogeneous_masked_arrays(masked_arrays: Sequence[BaseMaskedArray]) -> list[BaseMaskedArray]:
    """Transpose masked arrays in a list, but faster.

    Input should be a list of 1-dim masked arrays of equal length and all have the
    same dtype. The caller is responsible for ensuring validity of input data.
    """
    ...

