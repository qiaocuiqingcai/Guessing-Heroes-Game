"""
This type stub file was generated by pyright.
"""

import numpy as np
from typing import Any, Callable, Literal, TYPE_CHECKING, final
from pandas._libs import internals as libinternals
from pandas._libs.internals import BlockPlacement, BlockValuesRefs
from pandas._typing import ArrayLike, AxisInt, DtypeBackend, DtypeObj, F, FillnaOptions, IgnoreRaise, InterpolateOptions, QuantileInterpolation, Self, Shape, npt
from pandas.util._decorators import cache_readonly
from pandas.core.arrays import DatetimeArray, ExtensionArray, TimedeltaArray
from pandas.core.base import PandasObject
from collections.abc import Iterable, Sequence
from pandas.core.api import Index
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray

if TYPE_CHECKING:
    ...
_dtype_obj = ...
COW_WARNING_GENERAL_MSG = ...
COW_WARNING_SETITEM_MSG = ...
def maybe_split(meth: F) -> F:
    """
    If we have a multi-column block, split and operate block-wise.  Otherwise
    use the original method.
    """
    ...

class Block(PandasObject, libinternals.Block):
    """
    Canonical n-dimensional unit of homogeneous dtype contained in a pandas
    data structure

    Index-ignorant; let the container take care of that
    """
    values: np.ndarray | ExtensionArray
    ndim: int
    refs: BlockValuesRefs
    __init__: Callable
    __slots__ = ...
    is_numeric = ...
    @final
    @cache_readonly
    def is_object(self) -> bool:
        ...
    
    @final
    @cache_readonly
    def is_extension(self) -> bool:
        ...
    
    @final
    @property
    def is_bool(self) -> bool:
        """
        We can be bool if a) we are bool dtype or b) object dtype with bool objects.
        """
        ...
    
    @final
    def external_values(self): # -> ArrayLike:
        ...
    
    @final
    @cache_readonly
    def fill_value(self): # -> object | Any | float | Literal[0, False]:
        ...
    
    @property
    def mgr_locs(self) -> BlockPlacement:
        ...
    
    @mgr_locs.setter
    def mgr_locs(self, new_mgr_locs: BlockPlacement) -> None:
        ...
    
    @final
    def make_block(self, values, placement: BlockPlacement | None = ..., refs: BlockValuesRefs | None = ...) -> Block:
        """
        Create a new block, with type inference propagate any values that are
        not specified
        """
        ...
    
    @final
    def make_block_same_class(self, values, placement: BlockPlacement | None = ..., refs: BlockValuesRefs | None = ...) -> Self:
        """Wrap given values in a block of same type as self."""
        ...
    
    @final
    def __repr__(self) -> str:
        ...
    
    @final
    def __len__(self) -> int:
        ...
    
    @final
    def slice_block_columns(self, slc: slice) -> Self:
        """
        Perform __getitem__-like, return result as block.
        """
        ...
    
    @final
    def take_block_columns(self, indices: npt.NDArray[np.intp]) -> Self:
        """
        Perform __getitem__-like, return result as block.

        Only supports slices that preserve dimensionality.
        """
        ...
    
    @final
    def getitem_block_columns(self, slicer: slice, new_mgr_locs: BlockPlacement, ref_inplace_op: bool = ...) -> Self:
        """
        Perform __getitem__-like, return result as block.

        Only supports slices that preserve dimensionality.
        """
        ...
    
    @final
    def should_store(self, value: ArrayLike) -> bool:
        """
        Should we set self.values[indexer] = value inplace or do we need to cast?

        Parameters
        ----------
        value : np.ndarray or ExtensionArray

        Returns
        -------
        bool
        """
        ...
    
    @final
    def apply(self, func, **kwargs) -> list[Block]:
        """
        apply the function to my values; return a block if we are not
        one
        """
        ...
    
    @final
    def reduce(self, func) -> list[Block]:
        ...
    
    @final
    def split_and_operate(self, func, *args, **kwargs) -> list[Block]:
        """
        Split the block and apply func column-by-column.

        Parameters
        ----------
        func : Block method
        *args
        **kwargs

        Returns
        -------
        List[Block]
        """
        ...
    
    @final
    def coerce_to_target_dtype(self, other, warn_on_upcast: bool = ..., using_cow: bool = ...) -> Block:
        """
        coerce the current block to a dtype compat for other
        we will return a block, possibly object, and not raise

        we can also safely try to coerce to the same dtype
        and will receive the same block
        """
        ...
    
    @final
    def convert(self, *, copy: bool = ..., using_cow: bool = ..., convert_string: bool = ...) -> list[Block]:
        """
        Attempt to coerce any object types to better types. Return a copy
        of the block (if copy = True).
        """
        ...
    
    def convert_dtypes(self, copy: bool, using_cow: bool, infer_objects: bool = ..., convert_string: bool = ..., convert_integer: bool = ..., convert_boolean: bool = ..., convert_floating: bool = ..., dtype_backend: DtypeBackend = ...) -> list[Block]:
        ...
    
    @final
    @cache_readonly
    def dtype(self) -> DtypeObj:
        ...
    
    @final
    def astype(self, dtype: DtypeObj, copy: bool = ..., errors: IgnoreRaise = ..., using_cow: bool = ..., squeeze: bool = ...) -> Block:
        """
        Coerce to the new dtype.

        Parameters
        ----------
        dtype : np.dtype or ExtensionDtype
        copy : bool, default False
            copy if indicated
        errors : str, {'raise', 'ignore'}, default 'raise'
            - ``raise`` : allow exceptions to be raised
            - ``ignore`` : suppress exceptions. On error return original object
        using_cow: bool, default False
            Signaling if copy on write copy logic is used.
        squeeze : bool, default False
            squeeze values to ndim=1 if only one column is given

        Returns
        -------
        Block
        """
        ...
    
    @final
    def get_values_for_csv(self, *, float_format, date_format, decimal, na_rep: str = ..., quoting=...) -> Block:
        """convert to our native types format"""
        ...
    
    @final
    def copy(self, deep: bool = ...) -> Self:
        """copy constructor"""
        ...
    
    @final
    def replace(self, to_replace, value, inplace: bool = ..., mask: npt.NDArray[np.bool_] | None = ..., using_cow: bool = ..., already_warned=..., convert_string=...) -> list[Block]:
        """
        replace the to_replace value with value, possible to create new
        blocks here this is just a call to putmask.
        """
        ...
    
    @final
    def replace_list(self, src_list: Iterable[Any], dest_list: Sequence[Any], inplace: bool = ..., regex: bool = ..., using_cow: bool = ..., already_warned=...) -> list[Block]:
        """
        See BlockManager.replace_list docstring.
        """
        ...
    
    @property
    def shape(self) -> Shape:
        ...
    
    def iget(self, i: int | tuple[int, int] | tuple[slice, int]) -> np.ndarray:
        ...
    
    def set_inplace(self, locs, values: ArrayLike, copy: bool = ...) -> None:
        """
        Modify block values in-place with new item value.

        If copy=True, first copy the underlying values in place before modifying
        (for Copy-on-Write).

        Notes
        -----
        `set_inplace` never creates a new array or new Block, whereas `setitem`
        _may_ create a new array and always creates a new Block.

        Caller is responsible for checking values.dtype == self.dtype.
        """
        ...
    
    @final
    def take_nd(self, indexer: npt.NDArray[np.intp], axis: AxisInt, new_mgr_locs: BlockPlacement | None = ..., fill_value=...) -> Block:
        """
        Take values according to indexer and return them as a block.
        """
        ...
    
    def setitem(self, indexer, value, using_cow: bool = ...) -> Block:
        """
        Attempt self.values[indexer] = value, possibly creating a new array.

        Parameters
        ----------
        indexer : tuple, list-like, array-like, slice, int
            The subset of self.values to set
        value : object
            The value being set
        using_cow: bool, default False
            Signaling if CoW is used.

        Returns
        -------
        Block

        Notes
        -----
        `indexer` is a direct slice/positional indexer. `value` must
        be a compatible shape.
        """
        ...
    
    def putmask(self, mask, new, using_cow: bool = ..., already_warned=...) -> list[Block]:
        """
        putmask the data to the block; it is possible that we may create a
        new dtype of block

        Return the resulting block(s).

        Parameters
        ----------
        mask : np.ndarray[bool], SparseArray[bool], or BooleanArray
        new : a ndarray/object
        using_cow: bool, default False

        Returns
        -------
        List[Block]
        """
        ...
    
    def where(self, other, cond, _downcast: str | bool = ..., using_cow: bool = ...) -> list[Block]:
        """
        evaluate the block; return result block(s) from the result

        Parameters
        ----------
        other : a ndarray/object
        cond : np.ndarray[bool], SparseArray[bool], or BooleanArray
        _downcast : str or None, default "infer"
            Private because we only specify it when calling from fillna.

        Returns
        -------
        List[Block]
        """
        ...
    
    def fillna(self, value, limit: int | None = ..., inplace: bool = ..., downcast=..., using_cow: bool = ..., already_warned=...) -> list[Block]:
        """
        fillna on the block with the value. If we fail, then convert to
        block to hold objects instead and try again
        """
        ...
    
    def pad_or_backfill(self, *, method: FillnaOptions, axis: AxisInt = ..., inplace: bool = ..., limit: int | None = ..., limit_area: Literal["inside", "outside"] | None = ..., downcast: Literal["infer"] | None = ..., using_cow: bool = ..., already_warned=...) -> list[Block]:
        ...
    
    @final
    def interpolate(self, *, method: InterpolateOptions, index: Index, inplace: bool = ..., limit: int | None = ..., limit_direction: Literal["forward", "backward", "both"] = ..., limit_area: Literal["inside", "outside"] | None = ..., downcast: Literal["infer"] | None = ..., using_cow: bool = ..., already_warned=..., **kwargs) -> list[Block]:
        ...
    
    @final
    def diff(self, n: int) -> list[Block]:
        """return block for the diff of the values"""
        ...
    
    def shift(self, periods: int, fill_value: Any = ...) -> list[Block]:
        """shift the block by periods, possibly upcast"""
        ...
    
    @final
    def quantile(self, qs: Index, interpolation: QuantileInterpolation = ...) -> Block:
        """
        compute the quantiles of the

        Parameters
        ----------
        qs : Index
            The quantiles to be computed in float64.
        interpolation : str, default 'linear'
            Type of interpolation.

        Returns
        -------
        Block
        """
        ...
    
    @final
    def round(self, decimals: int, using_cow: bool = ...) -> Self:
        """
        Rounds the values.
        If the block is not of an integer or float dtype, nothing happens.
        This is consistent with DataFrame.round behavivor.
        (Note: Series.round would raise)

        Parameters
        ----------
        decimals: int,
            Number of decimal places to round to.
            Caller is responsible for validating this
        using_cow: bool,
            Whether Copy on Write is enabled right now
        """
        ...
    
    def delete(self, loc) -> list[Block]:
        """Deletes the locs from the block.

        We split the block to avoid copying the underlying data. We create new
        blocks for every connected segment of the initial block that is not deleted.
        The new blocks point to the initial array.
        """
        ...
    
    @property
    def is_view(self) -> bool:
        """return a boolean if I am possibly a view"""
        ...
    
    @property
    def array_values(self) -> ExtensionArray:
        """
        The array that Series.array returns. Always an ExtensionArray.
        """
        ...
    
    def get_values(self, dtype: DtypeObj | None = ...) -> np.ndarray:
        """
        return an internal format, currently just the ndarray
        this is often overridden to handle to_dense like operations
        """
        ...
    


class EABackedBlock(Block):
    """
    Mixin for Block subclasses backed by ExtensionArray.
    """
    values: ExtensionArray
    @final
    def shift(self, periods: int, fill_value: Any = ...) -> list[Block]:
        """
        Shift the block by `periods`.

        Dispatches to underlying ExtensionArray and re-boxes in an
        ExtensionBlock.
        """
        ...
    
    @final
    def setitem(self, indexer, value, using_cow: bool = ...): # -> Self | Block:
        """
        Attempt self.values[indexer] = value, possibly creating a new array.

        This differs from Block.setitem by not allowing setitem to change
        the dtype of the Block.

        Parameters
        ----------
        indexer : tuple, list-like, array-like, slice, int
            The subset of self.values to set
        value : object
            The value being set
        using_cow: bool, default False
            Signaling if CoW is used.

        Returns
        -------
        Block

        Notes
        -----
        `indexer` is a direct slice/positional indexer. `value` must
        be a compatible shape.
        """
        ...
    
    @final
    def where(self, other, cond, _downcast: str | bool = ..., using_cow: bool = ...) -> list[Block]:
        ...
    
    @final
    def putmask(self, mask, new, using_cow: bool = ..., already_warned=...) -> list[Block]:
        """
        See Block.putmask.__doc__
        """
        ...
    
    @final
    def delete(self, loc) -> list[Block]:
        ...
    
    @final
    @cache_readonly
    def array_values(self) -> ExtensionArray:
        ...
    
    @final
    def get_values(self, dtype: DtypeObj | None = ...) -> np.ndarray:
        """
        return object dtype as boxed values, such as Timestamps/Timedelta
        """
        ...
    
    @final
    def pad_or_backfill(self, *, method: FillnaOptions, axis: AxisInt = ..., inplace: bool = ..., limit: int | None = ..., limit_area: Literal["inside", "outside"] | None = ..., downcast: Literal["infer"] | None = ..., using_cow: bool = ..., already_warned=...) -> list[Block]:
        ...
    


class ExtensionBlock(EABackedBlock):
    """
    Block for holding extension types.

    Notes
    -----
    This holds all 3rd-party extension array types. It's also the immediate
    parent class for our internal extension types' blocks.

    ExtensionArrays are limited to 1-D.
    """
    values: ExtensionArray
    def fillna(self, value, limit: int | None = ..., inplace: bool = ..., downcast=..., using_cow: bool = ..., already_warned=...) -> list[Block]:
        ...
    
    @cache_readonly
    def shape(self) -> Shape:
        ...
    
    def iget(self, i: int | tuple[int, int] | tuple[slice, int]): # -> ExtensionArray | Any:
        ...
    
    def set_inplace(self, locs, values: ArrayLike, copy: bool = ...) -> None:
        ...
    
    @property
    def is_view(self) -> bool:
        """Extension arrays are never treated as views."""
        ...
    
    @cache_readonly
    def is_numeric(self) -> bool:
        ...
    
    @final
    def slice_block_rows(self, slicer: slice) -> Self:
        """
        Perform __getitem__-like specialized to slicing along index.
        """
        ...
    


class NumpyBlock(Block):
    values: np.ndarray
    __slots__ = ...
    @property
    def is_view(self) -> bool:
        """return a boolean if I am possibly a view"""
        ...
    
    @property
    def array_values(self) -> ExtensionArray:
        ...
    
    def get_values(self, dtype: DtypeObj | None = ...) -> np.ndarray:
        ...
    
    @cache_readonly
    def is_numeric(self) -> bool:
        ...
    


class NumericBlock(NumpyBlock):
    __slots__ = ...


class ObjectBlock(NumpyBlock):
    __slots__ = ...


class NDArrayBackedExtensionBlock(EABackedBlock):
    """
    Block backed by an NDArrayBackedExtensionArray
    """
    values: NDArrayBackedExtensionArray
    @property
    def is_view(self) -> bool:
        """return a boolean if I am possibly a view"""
        ...
    


class DatetimeLikeBlock(NDArrayBackedExtensionBlock):
    """Block for datetime64[ns], timedelta64[ns]."""
    __slots__ = ...
    is_numeric = ...
    values: DatetimeArray | TimedeltaArray


class DatetimeTZBlock(DatetimeLikeBlock):
    """implement a datetime64 block with a tz attribute"""
    values: DatetimeArray
    __slots__ = ...


def maybe_coerce_values(values: ArrayLike) -> ArrayLike:
    """
    Input validation for values passed to __init__. Ensure that
    any datetime64/timedelta64 dtypes are in nanoseconds.  Ensure
    that we do not have string dtypes.

    Parameters
    ----------
    values : np.ndarray or ExtensionArray

    Returns
    -------
    values : np.ndarray or ExtensionArray
    """
    ...

def get_block_type(dtype: DtypeObj) -> type[Block]:
    """
    Find the appropriate Block subclass to use for the given values and dtype.

    Parameters
    ----------
    dtype : numpy or pandas dtype

    Returns
    -------
    cls : class, subclass of Block
    """
    ...

def new_block_2d(values: ArrayLike, placement: BlockPlacement, refs: BlockValuesRefs | None = ...): # -> Block:
    ...

def new_block(values, placement: BlockPlacement, *, ndim: int, refs: BlockValuesRefs | None = ...) -> Block:
    ...

def check_ndim(values, placement: BlockPlacement, ndim: int) -> None:
    """
    ndim inference and validation.

    Validates that values.ndim and ndim are consistent.
    Validates that len(values) and len(placement) are consistent.

    Parameters
    ----------
    values : array-like
    placement : BlockPlacement
    ndim : int

    Raises
    ------
    ValueError : the number of dimensions do not match
    """
    ...

def extract_pandas_array(values: ArrayLike, dtype: DtypeObj | None, ndim: int) -> tuple[ArrayLike, DtypeObj | None]:
    """
    Ensure that we don't allow NumpyExtensionArray / NumpyEADtype in internals.
    """
    ...

def extend_blocks(result, blocks=...) -> list[Block]:
    """return a new extended blocks, given the result"""
    ...

def ensure_block_shape(values: ArrayLike, ndim: int = ...) -> ArrayLike:
    """
    Reshape if possible to have values.ndim == ndim.
    """
    ...

def external_values(values: ArrayLike) -> ArrayLike:
    """
    The array that Series.values returns (public attribute).

    This has some historical constraints, and is overridden in block
    subclasses to return the correct array (e.g. period returns
    object ndarray and datetimetz a datetime64[ns] ndarray instead of
    proper extension array).
    """
    ...

